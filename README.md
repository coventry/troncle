# troncle

Troncle is a proof-of-concept integration of clojure's tracing tools
with emacs.

`clojure.tools.trace` is super-handy, but wrapping various forms in your
code with `(ctt/trace ...)` as you explore how it's working gets
tedious.  The main idea with troncle is to take most of that tedium
away.

This is a very rough first cut, which I've published mostly because I'm
hoping to talk to people at the Clojure Conj about what directions to
take it in.  If this seems like an interesting project to you, please
take a look at the [roadmap](#roadmap) and let me know what you think.
(Whether you're at the Conj or not, of course.)  If it seems useless or
otherwise misguided, please also let me know what you think. :-) All
feedback is welcome.

## Usage

Currently, troncle has one function: You mark a region of your code,
hit`M-x troncle-trace-region` (`C-c t R`), and troncle sends the
top-level defun containing point to clojure.  Any forms contained in the
marked region, as well as any forms generated by their macroexpansion,
are instrumented with `clojure.tools.trace/trace` so that the results of
their evaluation during execution are reported in the repl buffer.

In order to do this, you have to let troncle know how to execute the
code.  You do this using the atom
`troncle.traces/trace-execution-function`.

For instance, suppose that you have the following code in `tst.clj`:

```clojure
(ns troncle.tst)

(defn ^String capitalize
  [^CharSequence s]
  (let [s (.toString s)]
    (if (< (count s) 2)
      (.toUpperCase s)
      (str (.toUpperCase (subs s 0 1))
           (.toLowerCase (subs s 1))))))
```

After [installing](#installation) troncle and compiling this file with
`C-c C-k`, type the following into the nrepl buffer to tell troncle how
you want to test this function:

```clojure
user> (troncle.traces/st #(println (troncle.tst/capitalize "foo")))
```

Now go to the tst.clj buffer,  and select all the text from just after
`defn` to just below the `if` symbol.  Type `C-c t R`, and the following
should appear in the nrepl buffer:

```clojure
TRACE [4 11] (.toString s): "foo"
TRACE [5 12] (count s): 3
TRACE [5 9] (< (count s) 2): false
Foo
```

`[4 11]` gives the line/column position of the form `(.toString s) in
the buffer.  `"foo"` is the result of its evaluation.  Only three forms
are traced, because those are the only forms in the selected region.

## Installation

For now this is very manual.

0. In the shell, `git clone https://github.com/coventry/troncle.git`

1. In emacs, open `nrepl-discover.el` in the troncle repository and run
   `M-x eval-buffer`.  (At the time I'm writing this the nrepl-discover
   marmalade package is out of date and incompatible with troncle.)

2. In the `project.clj` file for the lein project where you want to use
   troncle, add

   ```clojure
   :repl-options {:nrepl-middleware [nrepl.discover/wrap-discover]}
   ```

   Also add `[troncle "0.1.0-SNAPSHOT"]` to your project.clj's
   `:dependencies` vector.
   
  You can also add these modifications to your `:user` map in your
  `~/.lein/profiles.clj`.

3. `M-x nrepl-jack-in` in your target project.  (Restart the jvm if
   necessary, to get the nrepl-discover middleware operating.)

5. In emacs, open the resulting `troncle.el` then `M-x eval-buffer`

6. Open `src/troncle/core.clj` and hit `C-c C-k` while there to compile
   it.	

7. In the nrepl buffer, set the command to be executed by troncle using
   `tronce.traces/st` (see [Usage](usage) for an example.)

8. Go to the buffer with the code you want to explore, compile it with
   `C-c C-k`, mark the forms you want traced, and hit `C-c t R`!

## License

Copyright Â© 2013 Alex Coventry

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
