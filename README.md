# troncle

Troncle is a proof-of-concept integration of clojure's tracing tools
with emacs, built around technomancy's innovative nrepl-discover and
a robust (very simple) code-walking/wrapping macro I've developed.


`clojure.tools.trace` is super-handy, but wrapping various forms in your
code with `(ctt/trace ...)` as you explore how it's working gets
tedious.  The main idea with troncle is to take most of that tedium
away.

This is a very rough first cut, which I've published mostly because I'm
hoping to talk to people at the Clojure Conj about what directions to
take it in.  If this seems like an interesting project to you, please
take a look at the [roadmap](#roadmap) and let me know what you think.
(Whether you're at the Conj or not, of course.)  If it seems useless or
otherwise misguided, please also let me know what you think. :-) All
feedback is welcome.

## Usage

Currently, troncle has one function: You mark a region of your code,
hit`M-x troncle-trace-region` (`C-c t R`), and troncle sends the
top-level defun containing point to clojure.  Any forms contained in the
marked region, as well as any forms generated by their macroexpansion,
are instrumented with `clojure.tools.trace/trace` so that the results of
their evaluation during execution are reported in the repl buffer.

In order to do this, you have to let troncle know how to execute the
code.  You tell it using the function `troncle.traces/st` (for "set
test.")

For instance, suppose that you have the following code in `tst.clj`:

```clojure
(ns troncle.tst)

(defn ^String capitalize
  [^CharSequence s]
  (let [s (.toString s)]
    (if (< (count s) 2)
      (.toUpperCase s)
      (str (.toUpperCase (subs s 0 1))
           (.toLowerCase (subs s 1))))))
```

After [installing](#installation) troncle and compiling this file with
`C-c C-k`, type the following into the nrepl buffer to tell troncle how
you want to test this function:

```clojure
user> (troncle.traces/st #(println (troncle.tst/capitalize "foo")))
```

Now go to the tst.clj buffer,  and select all the text from just after
`defn` to just below the `if` symbol.  Type `C-c t R`, and the following
should appear in the nrepl buffer:

```clojure
TRACE [4 11] (.toString s): "foo"
TRACE [5 12] (count s): 3
TRACE [5 9] (< (count s) 2): false
Foo
```

`[4 11]` gives the line/column position of the form `(.toString s) in
the buffer.  `"foo"` is the result of its evaluation.  Only three forms
are traced, because those are the only forms in the selected region.

## Installation

For now this is very manual.

0. In the shell, `git clone https://github.com/coventry/troncle.git`

1. In emacs, open `nrepl-discover.el` in the troncle repository and run
   `M-x eval-buffer`.  (At the time I'm writing this the
   [nrepl-discover](https://github.com/technomancy/nrepl-discover)
   marmalade package is out of date and incompatible with troncle.)

2. In the `project.clj` file for the lein project where you want to use
   troncle, add

   ```clojure
   :repl-options {:nrepl-middleware [nrepl.discover/wrap-discover]}
   ```

   Also add `[troncle "0.1.0-SNAPSHOT"]` to your project.clj's
   `:dependencies` vector.
   
  You can also add these modifications to your `:user` map in your
  `~/.lein/profiles.clj`.

3. `M-x nrepl-jack-in` in your target project.  (Restart the jvm if
   necessary, to get the nrepl-discover middleware operating.)

5. In emacs, open the `troncle.el` from the troncle git repository, then
   `M-x eval-buffer`

7. In the nrepl buffer, set the command to be executed by troncle using
   `tronce.traces/st` (see [Usage](usage) for an example.)

8. Go to the buffer with the code you want to explore, compile it with
   `C-c C-k`, mark the forms you want traced, and hit `C-c t R`!

## Roadmap


### Extended functionality

This is a very simple application at the moment, but I think it has a
lot of potential.  The core functionality is in `troncle.macroshka`,
which is a very robust code-walking scheme.  (I've run it over the
entire clojure source code.)

These are the directions I'd like to move it in:

1. Emacs convenience functions for passing "load this file" and "run
   this test" functions to `tronce.traces/st`.

2. Tracing instrumentation for multiple regions within a top-level
   form. 

3. Filtered tracing: Only report a trace when a given predicate returns
   true.  Predicate can be specified in terms of return values of the
   forms under consideration.

4. Save and restore current tracing configuration.

5. Tracing of bindings to local variables.

6. Send trace reports to a clojure list, rather than/as well as the
   repl, so that they can be queried programmatically.

7. Replay a series of trace reports using emacs overlays
   (nrepl-discover's overlay facility should make this easy.)

8. Replace the tracing with source-level step debugging.

## Cleaning up

1. Currently this depends on private (bleeding-edge) copies of
   `nrepl-discover.el` and `clojure.tools.reader`.  These need to be
   changed to canonical dependencies as they become available.
   
2. A lot of troncle.el's behaviors may be more generally useful to other
   users of nrepl-discover.el.

3. You tell me.

## License

Copyright Â© 2013 Alex Coventry

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
